{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { createPopper } from '@popperjs/core';\nimport { get } from 'lodash-unified';\nimport escapeHtml from 'escape-html';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { hasOwn } from '@vue/shared';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nimport { off, on } from '../../../utils/dom/event.mjs';\nconst getCell = function (event) {\n  let cell = event.target;\n  while (cell && cell.tagName.toUpperCase() !== \"HTML\") {\n    if (cell.tagName.toUpperCase() === \"TD\") {\n      return cell;\n    }\n    cell = cell.parentNode;\n  }\n  return null;\n};\nconst isObject = function (obj) {\n  return obj !== null && typeof obj === \"object\";\n};\nconst orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n  if (typeof reverse === \"string\") {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n  const getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      if (!Array.isArray(sortBy)) {\n        sortBy = [sortBy];\n      }\n      return sortBy.map(by => {\n        if (typeof by === \"string\") {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n    return [isObject(value) ? get(value, sortKey) : value];\n  };\n  const compare = function (a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n    for (let i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1;\n      }\n      if (a.key[i] > b.key[i]) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n  return array.map((value, index) => {\n    return {\n      value,\n      index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort((a, b) => {\n    let order = compare(a, b);\n    if (!order) {\n      order = a.index - b.index;\n    }\n    return order * +reverse;\n  }).map(item => item.value);\n};\nconst getColumnById = function (table, columnId) {\n  let column = null;\n  table.columns.forEach(item => {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\nconst getColumnByKey = function (table, columnKey) {\n  let column = null;\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i];\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n  return column;\n};\nconst getColumnByCell = function (table, cell, namespace) {\n  const matches = (cell.className || \"\").match(new RegExp(`${namespace}-table_[^\\\\s]+`, \"gm\"));\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n  return null;\n};\nconst getRowIdentity = (row, rowKey) => {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n  if (typeof rowKey === \"string\") {\n    if (!rowKey.includes(\".\")) {\n      return `${row[rowKey]}`;\n    }\n    const key = rowKey.split(\".\");\n    let current = row;\n    for (const element of key) {\n      current = current[element];\n    }\n    return `${current}`;\n  } else if (typeof rowKey === \"function\") {\n    return rowKey.call(null, row);\n  }\n};\nconst getKeysMap = function (array, rowKey) {\n  const arrayMap = {};\n  (array || []).forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row,\n      index\n    };\n  });\n  return arrayMap;\n};\nfunction mergeOptions(defaults, config) {\n  const options = {};\n  let key;\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key];\n      if (typeof value !== \"undefined\") {\n        options[key] = value;\n      }\n    }\n  }\n  return options;\n}\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n  if (width !== void 0) {\n    width = Number.parseInt(width, 10);\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n  return width;\n}\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n  if (minWidth !== void 0) {\n    minWidth = parseWidth(minWidth);\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n  return minWidth;\n}\nfunction parseHeight(height) {\n  if (typeof height === \"number\") {\n    return height;\n  }\n  if (typeof height === \"string\") {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n  return null;\n}\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\nfunction toggleRowStatus(statusArr, row, newVal) {\n  let changed = false;\n  const index = statusArr.indexOf(row);\n  const included = index !== -1;\n  const addRow = () => {\n    statusArr.push(row);\n    changed = true;\n  };\n  const removeRow = () => {\n    statusArr.splice(index, 1);\n    changed = true;\n  };\n  if (typeof newVal === \"boolean\") {\n    if (newVal && !included) {\n      addRow();\n    } else if (!newVal && included) {\n      removeRow();\n    }\n  } else {\n    if (included) {\n      removeRow();\n    } else {\n      addRow();\n    }\n  }\n  return changed;\n}\nfunction walkTreeNode(root, cb, childrenKey = \"children\", lazyKey = \"hasChildren\") {\n  const isNil = array => !(Array.isArray(array) && array.length);\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(item => {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1);\n        return;\n      }\n      const children2 = item[childrenKey];\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n  root.forEach(item => {\n    if (item[lazyKey]) {\n      cb(item, null, 0);\n      return;\n    }\n    const children = item[childrenKey];\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\nlet removePopper;\nfunction createTablePopper(trigger, popperContent, popperOptions, tooltipEffect) {\n  const {\n    nextZIndex\n  } = useZIndex();\n  function renderContent() {\n    const isLight = tooltipEffect === \"light\";\n    const content2 = document.createElement(\"div\");\n    content2.className = `el-popper ${isLight ? \"is-light\" : \"is-dark\"}`;\n    popperContent = escapeHtml(popperContent);\n    content2.innerHTML = popperContent;\n    content2.style.zIndex = String(nextZIndex());\n    document.body.appendChild(content2);\n    return content2;\n  }\n  function renderArrow() {\n    const arrow2 = document.createElement(\"div\");\n    arrow2.className = \"el-popper__arrow\";\n    return arrow2;\n  }\n  function showPopper() {\n    popperInstance && popperInstance.update();\n  }\n  removePopper = function removePopper2() {\n    try {\n      popperInstance && popperInstance.destroy();\n      content && document.body.removeChild(content);\n      off(trigger, \"mouseenter\", showPopper);\n      off(trigger, \"mouseleave\", removePopper2);\n    } catch (e) {}\n  };\n  let popperInstance = null;\n  const content = renderContent();\n  const arrow = renderArrow();\n  content.appendChild(arrow);\n  popperInstance = createPopper(trigger, content, {\n    modifiers: [{\n      name: \"offset\",\n      options: {\n        offset: [0, 8]\n      }\n    }, {\n      name: \"arrow\",\n      options: {\n        element: arrow,\n        padding: 10\n      }\n    }],\n    ...popperOptions\n  });\n  on(trigger, \"mouseenter\", showPopper);\n  on(trigger, \"mouseleave\", removePopper);\n  return popperInstance;\n}\nconst isFixedColumn = (index, fixed, store, realColumns) => {\n  let start = 0;\n  let after = index;\n  if (realColumns) {\n    if (realColumns[index].colSpan > 1) {\n      return {};\n    }\n    for (let i = 0; i < index; i++) {\n      start += realColumns[i].colSpan;\n    }\n    after = start + realColumns[index].colSpan - 1;\n  } else {\n    start = index;\n  }\n  let fixedLayout;\n  const columns = store.states.columns;\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n      break;\n    case \"right\":\n      if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n      break;\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n  }\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start,\n    after\n  } : {};\n};\nconst getFixedColumnsClass = (namespace, index, fixed, store, realColumns) => {\n  const classes = [];\n  const {\n    direction,\n    start\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (direction) {\n    const isLeft = direction === \"left\";\n    classes.push(`${namespace}-fixed-column--${direction}`);\n    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n  return classes;\n};\nfunction getOffset(offset, column) {\n  return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\nconst getFixedColumnOffset = (index, fixed, store, realColumns) => {\n  const {\n    direction,\n    start = 0\n  } = isFixedColumn(index, fixed, store, realColumns);\n  if (!direction) {\n    return;\n  }\n  const styles = {};\n  const isLeft = direction === \"left\";\n  const columns = store.states.columns.value;\n  if (isLeft) {\n    styles.left = columns.slice(0, index).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(start + 1).reverse().reduce(getOffset, 0);\n  }\n  return styles;\n};\nconst ensurePosition = (style, key) => {\n  if (!style) return;\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`;\n  }\n};\nexport { compose, createTablePopper, ensurePosition, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":{"version":3,"mappings":"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","names":["getCell","event","cell","target","tagName","toUpperCase","parentNode","isObject","obj","orderBy","array","sortKey","reverse","sortMethod","sortBy","Array","isArray","length","getKey","value","index","map","by","get","$value","compare","a","b","i","len","key","sort","order","item","getColumnById","table","columnId","column","columns","forEach","id","getColumnByKey","columnKey","getColumnByCell","namespace","matches","className","match","RegExp","getRowIdentity","row","rowKey","Error","includes","split","current","element","call","getKeysMap","arrayMap","mergeOptions","defaults","config","options","hasOwn","parseWidth","width","Number","parseInt","isNaN","parseMinWidth","minWidth","parseHeight","height","test","compose","funcs","arg","reduce","args","toggleRowStatus","statusArr","newVal","changed","indexOf","included","addRow","push","removeRow","splice","walkTreeNode","root","cb","childrenKey","lazyKey","isNil","_walker","parent","children","level","children2","removePopper","createTablePopper","trigger","popperContent","popperOptions","tooltipEffect","nextZIndex","useZIndex","renderContent","isLight","content2","document","createElement","escapeHtml","innerHTML","style","zIndex","String","body","appendChild","renderArrow","arrow2","showPopper","popperInstance","update","removePopper2","destroy","content","removeChild","off","e","arrow","createPopper","modifiers","name","offset","padding","on","isFixedColumn","fixed","store","realColumns","start","after","colSpan","fixedLayout","states","fixedLeafColumnsLength","rightFixedLeafColumnsLength","direction","getFixedColumnsClass","classes","isLeft","getOffset","realWidth","getFixedColumnOffset","styles","left","slice","right","ensurePosition"],"sources":["../../../../../../packages/components/table/src/util.ts"],"sourcesContent":["import { createPopper } from '@popperjs/core'\nimport { get } from 'lodash-unified'\nimport escapeHtml from 'escape-html'\nimport { hasOwn, off, on } from '@element-plus/utils'\nimport { useZIndex } from '@element-plus/hooks'\nimport type {\n  PopperInstance,\n  IPopperOptions,\n} from '@element-plus/components/popper'\nimport type { Nullable } from '@element-plus/utils'\nimport type { TableColumnCtx } from './table-column/defaults'\n\nexport const getCell = function (event: Event): HTMLElement {\n  let cell = event.target as HTMLElement\n\n  while (cell && cell.tagName.toUpperCase() !== 'HTML') {\n    if (cell.tagName.toUpperCase() === 'TD') {\n      return cell\n    }\n    cell = cell.parentNode as HTMLElement\n  }\n\n  return null\n}\n\nconst isObject = function (obj: unknown): boolean {\n  return obj !== null && typeof obj === 'object'\n}\n\nexport const orderBy = function <T>(\n  array: T[],\n  sortKey: string,\n  reverse: string | number,\n  sortMethod,\n  sortBy: string | (string | ((a: T, b: T, array?: T[]) => number))[]\n) {\n  if (\n    !sortKey &&\n    !sortMethod &&\n    (!sortBy || (Array.isArray(sortBy) && !sortBy.length))\n  ) {\n    return array\n  }\n  if (typeof reverse === 'string') {\n    reverse = reverse === 'descending' ? -1 : 1\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1\n  }\n  const getKey = sortMethod\n    ? null\n    : function (value, index) {\n        if (sortBy) {\n          if (!Array.isArray(sortBy)) {\n            sortBy = [sortBy]\n          }\n          return sortBy.map((by) => {\n            if (typeof by === 'string') {\n              return get(value, by)\n            } else {\n              return by(value, index, array)\n            }\n          })\n        }\n        if (sortKey !== '$key') {\n          if (isObject(value) && '$value' in value) value = value.$value\n        }\n        return [isObject(value) ? get(value, sortKey) : value]\n      }\n  const compare = function (a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value)\n    }\n    for (let i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1\n      }\n      if (a.key[i] > b.key[i]) {\n        return 1\n      }\n    }\n    return 0\n  }\n  return array\n    .map((value, index) => {\n      return {\n        value,\n        index,\n        key: getKey ? getKey(value, index) : null,\n      }\n    })\n    .sort((a, b) => {\n      let order = compare(a, b)\n      if (!order) {\n        // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n        order = a.index - b.index\n      }\n      return order * +reverse\n    })\n    .map((item) => item.value)\n}\n\nexport const getColumnById = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnId: string\n): null | TableColumnCtx<T> {\n  let column = null\n  table.columns.forEach((item) => {\n    if (item.id === columnId) {\n      column = item\n    }\n  })\n  return column\n}\n\nexport const getColumnByKey = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnKey: string\n): TableColumnCtx<T> {\n  let column = null\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i]\n    if (item.columnKey === columnKey) {\n      column = item\n      break\n    }\n  }\n  return column\n}\n\nexport const getColumnByCell = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  cell: HTMLElement,\n  namespace: string\n): null | TableColumnCtx<T> {\n  const matches = (cell.className || '').match(\n    new RegExp(`${namespace}-table_[^\\\\s]+`, 'gm')\n  )\n  if (matches) {\n    return getColumnById(table, matches[0])\n  }\n  return null\n}\n\nexport const getRowIdentity = <T>(\n  row: T,\n  rowKey: string | ((row: T) => any)\n): string => {\n  if (!row) throw new Error('Row is required when get row identity')\n  if (typeof rowKey === 'string') {\n    if (!rowKey.includes('.')) {\n      return `${row[rowKey]}`\n    }\n    const key = rowKey.split('.')\n    let current = row\n    for (const element of key) {\n      current = current[element]\n    }\n    return `${current}`\n  } else if (typeof rowKey === 'function') {\n    return rowKey.call(null, row)\n  }\n}\n\nexport const getKeysMap = function <T>(\n  array: T[],\n  rowKey: string\n): Record<string, { row: T; index: number }> {\n  const arrayMap = {}\n  ;(array || []).forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = { row, index }\n  })\n  return arrayMap\n}\n\nexport function mergeOptions<T, K>(defaults: T, config: K): T & K {\n  const options = {} as T & K\n  let key\n  for (key in defaults) {\n    options[key] = defaults[key]\n  }\n  for (key in config) {\n    if (hasOwn(config as unknown as Record<string, any>, key)) {\n      const value = config[key]\n      if (typeof value !== 'undefined') {\n        options[key] = value\n      }\n    }\n  }\n  return options\n}\n\nexport function parseWidth(width: number | string): number | string {\n  if (width === '') return width\n  if (width !== undefined) {\n    width = Number.parseInt(width as string, 10)\n    if (Number.isNaN(width)) {\n      width = ''\n    }\n  }\n  return width\n}\n\nexport function parseMinWidth(minWidth: number | string): number | string {\n  if (minWidth === '') return minWidth\n  if (minWidth !== undefined) {\n    minWidth = parseWidth(minWidth)\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80\n    }\n  }\n  return minWidth\n}\n\nexport function parseHeight(height: number | string) {\n  if (typeof height === 'number') {\n    return height\n  }\n  if (typeof height === 'string') {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return Number.parseInt(height, 10)\n    } else {\n      return height\n    }\n  }\n  return null\n}\n\n// https://github.com/reduxjs/redux/blob/master/src/compose.js\nexport function compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce(\n    (a, b) =>\n      (...args) =>\n        a(b(...args))\n  )\n}\n\nexport function toggleRowStatus<T>(\n  statusArr: T[],\n  row: T,\n  newVal: boolean\n): boolean {\n  let changed = false\n  const index = statusArr.indexOf(row)\n  const included = index !== -1\n\n  const addRow = () => {\n    statusArr.push(row)\n    changed = true\n  }\n  const removeRow = () => {\n    statusArr.splice(index, 1)\n    changed = true\n  }\n\n  if (typeof newVal === 'boolean') {\n    if (newVal && !included) {\n      addRow()\n    } else if (!newVal && included) {\n      removeRow()\n    }\n  } else {\n    if (included) {\n      removeRow()\n    } else {\n      addRow()\n    }\n  }\n  return changed\n}\n\nexport function walkTreeNode(\n  root,\n  cb,\n  childrenKey = 'children',\n  lazyKey = 'hasChildren'\n) {\n  const isNil = (array) => !(Array.isArray(array) && array.length)\n\n  function _walker(parent, children, level) {\n    cb(parent, children, level)\n    children.forEach((item) => {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1)\n        return\n      }\n      const children = item[childrenKey]\n      if (!isNil(children)) {\n        _walker(item, children, level + 1)\n      }\n    })\n  }\n\n  root.forEach((item) => {\n    if (item[lazyKey]) {\n      cb(item, null, 0)\n      return\n    }\n    const children = item[childrenKey]\n    if (!isNil(children)) {\n      _walker(item, children, 0)\n    }\n  })\n}\n\nexport let removePopper\n\nexport function createTablePopper(\n  trigger: HTMLElement,\n  popperContent: string,\n  popperOptions: Partial<IPopperOptions>,\n  tooltipEffect: string\n) {\n  const { nextZIndex } = useZIndex()\n  function renderContent(): HTMLDivElement {\n    const isLight = tooltipEffect === 'light'\n    const content = document.createElement('div')\n    content.className = `el-popper ${isLight ? 'is-light' : 'is-dark'}`\n    popperContent = escapeHtml(popperContent)\n    content.innerHTML = popperContent\n    content.style.zIndex = String(nextZIndex())\n    document.body.appendChild(content)\n    return content\n  }\n  function renderArrow(): HTMLDivElement {\n    const arrow = document.createElement('div')\n    arrow.className = 'el-popper__arrow'\n    return arrow\n  }\n  function showPopper() {\n    popperInstance && popperInstance.update()\n  }\n  removePopper = function removePopper() {\n    try {\n      popperInstance && popperInstance.destroy()\n      content && document.body.removeChild(content)\n      off(trigger, 'mouseenter', showPopper)\n      off(trigger, 'mouseleave', removePopper)\n    } catch {}\n  }\n  let popperInstance: Nullable<PopperInstance> = null\n  const content = renderContent()\n  const arrow = renderArrow()\n  content.appendChild(arrow)\n\n  popperInstance = createPopper(trigger, content, {\n    modifiers: [\n      {\n        name: 'offset',\n        options: {\n          offset: [0, 8],\n        },\n      },\n      {\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 10,\n        },\n      },\n    ],\n    ...popperOptions,\n  })\n  on(trigger, 'mouseenter', showPopper)\n  on(trigger, 'mouseleave', removePopper)\n  return popperInstance\n}\n\nexport const isFixedColumn = <T>(\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  let start = 0\n  let after = index\n  if (realColumns) {\n    if (realColumns[index].colSpan > 1) {\n      // fixed column not supported in grouped header\n      return {}\n    }\n    // handle group\n    for (let i = 0; i < index; i++) {\n      start += realColumns[i].colSpan\n    }\n    after = start + realColumns[index].colSpan - 1\n  } else {\n    start = index\n  }\n  let fixedLayout\n  const columns = store.states.columns\n  switch (fixed) {\n    case 'left':\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      }\n      break\n    case 'right':\n      if (\n        start >=\n        columns.value.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n      break\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      } else if (\n        start >=\n        columns.value.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n  }\n  return fixedLayout\n    ? {\n        direction: fixedLayout,\n        start,\n        after,\n      }\n    : {}\n}\n\nexport const getFixedColumnsClass = <T>(\n  namespace: string,\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const classes: string[] = []\n  const { direction, start } = isFixedColumn(index, fixed, store, realColumns)\n  if (direction) {\n    const isLeft = direction === 'left'\n    classes.push(`${namespace}-fixed-column--${direction}`)\n    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push('is-last-column')\n    } else if (\n      !isLeft &&\n      start ===\n        store.states.columns.value.length -\n          store.states.rightFixedLeafColumnsLength.value\n    ) {\n      classes.push('is-first-column')\n    }\n  }\n  return classes\n}\n\nfunction getOffset<T>(offset: number, column: TableColumnCtx<T>) {\n  return (\n    offset +\n    (column.realWidth === null || Number.isNaN(column.realWidth)\n      ? Number(column.width)\n      : column.realWidth)\n  )\n}\n\nexport const getFixedColumnOffset = <T>(\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const { direction, start = 0 } = isFixedColumn(\n    index,\n    fixed,\n    store,\n    realColumns\n  )\n  if (!direction) {\n    return\n  }\n  const styles: any = {}\n  const isLeft = direction === 'left'\n  const columns = store.states.columns.value\n  if (isLeft) {\n    styles.left = columns.slice(0, index).reduce(getOffset, 0)\n  } else {\n    styles.right = columns\n      .slice(start + 1)\n      .reverse()\n      .reduce(getOffset, 0)\n  }\n  return styles\n}\n\nexport const ensurePosition = (style, key: string) => {\n  if (!style) return\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`\n  }\n}\n"]},"metadata":{},"sourceType":"module"}